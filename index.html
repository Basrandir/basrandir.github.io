<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.19" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Bassam Saeed</title>
  

  
  <link rel="stylesheet" href="http://bassamsaeed.ca/css/poole.css">
  <link rel="stylesheet" href="http://bassamsaeed.ca/css/syntax.css">
  <link rel="stylesheet" href="http://bassamsaeed.ca/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="http://bassamsaeed.ca/index.xml" rel="alternate" type="application/rss+xml" title="Bassam Saeed" />
</head>

<body class=" ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://bassamsaeed.ca/"><h1>Bassam Saeed</h1></a>
      <p class="lead">
       Personal Dev Blog 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="http://bassamsaeed.ca/post/lxc-container-networking/">
        Setting up LXC with Networking
      </a>
    </h1>

    <span class="post-date">Sat, May 14, 2016</span>

    <p>From my understaning Ubuntu will setup a bridge by default when you install lxc. Or perhaps when you first create a container. I&rsquo;m not certain. This isn&rsquo;t the case in a lot of other distributions however.</p>

<p>In this guide we&rsquo;ll setup a network bridge. The bridge with be setup on the host system to aggregate the internal container networks with the outer network. In this way the host system will become a bridge from the router to the containers.</p>

<p>First create the virtual link and bring it up.</p>

<pre><code>ip link add name *bridge_name* type bridge
ip link set *bridge_name* up
</code></pre>

<p>Add an interface (presumably the LAN interface) to the bridge.</p>

<pre><code>ip link set *interface* master *bridge_name*
</code></pre>

<p>Get an IP address for the bridge.</p>

<pre><code>dhcpcd *bridge_name*
</code></pre>

<p>Confirm that the host has a proper connection.</p>

<pre><code>ping -c 1 www.bassamsaeed.ca
</code></pre>

<p>If everything is working then the bridge is working perfectly. The next step is to properly set up the containers to use the bridge.</p>

<p>First create the container. Use any preferred template.</p>

<pre><code>lxc-create -n *lxc_name* -t debian
</code></pre>

<p>Edit the config file of the container. This is usually located at <code>/var/lib/lxc/*lxc_name*/config</code>. Add the following two lines:</p>

<pre><code>## network
lxc.network.type = veth
lxc.network.link = *bridge_name*
</code></pre>

<p>This will create an virtual ethernet interface and link it with the bridge.</p>

<p>The guest container is now bridged with the network. DHCP may be configured in the guest container. Static IP may also be configured in the actual container or in the container config file as follows:</p>

<pre><code>lxc.network.ipv4 = 192.168.1.100/24
lxc.network.ipv4.gateway = 192.168.1.1
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://bassamsaeed.ca/post/encrypted-btrfs-archlinux/">
        How-To: Encrypted Btrfs install on Arch Linux
      </a>
    </h1>

    <span class="post-date">Mon, Jan 25, 2016</span>

    

<p>Setting up a Btrfs install while juggling encyption, UEFI, and swap can be tricky so I&rsquo;ve decided to put down my method here. Btrfs is very flexible and can do a lot of things from replacing the MBR/GPT schemes to RAID and then some. Unfortunately it does have some limitations. It doesn&rsquo;t have built-in encyption, doesn&rsquo;t support swap files and -not its fault- can&rsquo;t use UEFI to boot. Encryption can be solved using dm-crypt and the other issues by having their own partitions.</p>

<h2 id="partitioning">Partitioning</h2>

<p>To begin with decide how exactly the install will be set up. If UEFI boot isn&rsquo;t needed then there is no need for a separate EFI System Partition.</p>

<p><strong>Note:</strong> Skip this and the <em>Formatting</em> step if neither UEFI or swap is required.</p>

<p>For this example, create 3 partitions:</p>

<ol>
<li>A small EFI System Partition for UEFI boot. <em>~ 512M</em><br /></li>
<li>Swap partition for hibernation. <em>~ Size of RAM</em><br /></li>
<li>A final partition that will be the encrypted Btrfs Arch Linux install. <em>Rest of the drive.</em><br /></li>
</ol>

<p>When done it should look something like this:</p>

<pre><code>sda
 ├─ sda1     EFI     512 MB
 ├─ sda2     swap    2 GB
 └─ sda3             114 GB
</code></pre>

<p>Set the EFI partition as bootable using whatever method you used to create the partitions.</p>

<h2 id="formatting">Formatting</h2>

<p>Format the EFI and swap partitions correctly.</p>

<pre><code>mkfs.fat -F32 /dev/sda1
mkswap /dev/sda2
</code></pre>

<p>And activate swap:</p>

<pre><code>swapon /dev/sda2
</code></pre>

<h2 id="encyption">Encyption</h2>

<p>The first thing that needs to be done is to create a LUKS encrypted container in the final partition using dm-crypt.</p>

<pre><code>cryptsetup -vy luksFormat /dev/sda3
</code></pre>

<p>The -y option is required to verify the password. Make sure it&rsquo;s a secure password and don&rsquo;t forget it. It will be required at the start of every boot..</p>

<p>Next unlock the encrypted container and enter the password:</p>

<pre><code>cryptsetup open /dev/sda3 btrfsroot
</code></pre>

<p>Replace <code>btrfsroot</code> with any preferred name. This will map the LUKS container to <code>/dev/mapper/btrfsroot</code>.</p>

<p>Create the btrfs filesystem:</p>

<pre><code>mkfs.btrfs -L &quot;arch&quot; /dev/mapper/btrfsroot
</code></pre>

<p>The <code>arch</code> label will be used to mount the various Btrfs subvolumes in fstab. The layout should now look something like this:</p>

<pre><code>sda
 ├─ sda1             EFI             512M
 ├─ sda2             swap            2G
 └─ sda3             crypto_LUKS     114G
      └─ btrfsroot   Btrfs           114G
</code></pre>

<p><strong>Note:</strong> Encrypting the swap partition is outside the scope of this article but is possible if needed. See <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Swap_encryption">dmcrypt/Swap encryption</a>.</p>

<h2 id="setting-up-btrfs-and-installing-arch-linux">Setting up Btrfs and installing Arch Linux</h2>

<p>Properly create and mount the subvolumes for the actual Arch Linux install.</p>

<p>First mount the container:</p>

<pre><code>mount /dev/mapper/btrfsroot /mnt
cd /mnt
</code></pre>

<p>Now create the subvolumes. In Btrfs these essentially replace (or complement) the traditional partitions scheme. The ultimate scheme is preferencial. This is just one example. There are an infinite number of ways to create and mount subvolumes.</p>

<pre><code>btrfs subvolume create __arch
btrfs subvolume create __arch/root
btrfs subvolume create __arch/home
btrfs subvolume create __snapshots
</code></pre>

<p>There is one subvolume for the root(<code>/</code>) directory and one for the home(<code>/home</code>) directory. The <code>__snapshots</code> subvolume is where the snapshots of the subvolumes will be stored. Snapshots can be created of the <code>root</code> or <code>home</code> subvolumes (or both by snapshotting <code>__arch</code>) prior to major upgrades as a form of backup. They can also be automated via simple scripts.</p>

<p>View the subvolumes:</p>

<pre><code>btrfs subvolume list .
</code></pre>

<p>Unmount the LUKS container:</p>

<pre><code>cd
umount -R /mnt
</code></pre>

<p>Decide where to mount the subvolumes and create the appropriate directories.</p>

<pre><code>mount -o subvol=__arch/root /dev/mapper/btrfsroot /mnt
mkdir /mnt/{home,.snapshots}
mount -o subvol=__arch/home /dev/mapper/btrfsroot /mnt/home
mount -o subvol=__snapshots /dev/mapper/btrfsroot /mnt/.snapshots
</code></pre>

<p>This mounts the corresponding subvolumes of the btrfsroot Btrfs filesystem to their appropriate locations.</p>

<p>Mount the EFI System Partition:</p>

<pre><code>mkdir /mnt/boot
mount /dev/sda1 /mnt/boot
</code></pre>

<p>Select the fastest mirrors and install Arch Linux</p>

<pre><code>pacstrap -i /mnt base base-devel btrfs-progs
</code></pre>

<p>The btrfs-progs package is required in order to manipulate the btrfs install.</p>

<h2 id="post-installation">Post Installation</h2>

<p>Generate the fstab file:</p>

<pre><code>genfstab -U /mnt &gt; /mnt/etc/fstab
</code></pre>

<p>genftab doesn&rsquo;t handle btrfs subvolumes very gracefully so edit the file. The subvolume mounting should look something like this:</p>

<pre><code>LABEL=arch  /           btrfs   rw,relatime,space_cache,subvol=__arch/root  0   0
LABEL=arch  /home       btrfs   rw,relatime,space_cache,subvol=__arch/home  0   0
LABEL=arch  /.snapshots btrfs   rw,relatime,space_cache,subvol=__snapshots  0   0
</code></pre>

<p>Remove any reference to subvolid in the fstab file. It will conflict with snapshot recovery because snapshots have a seperate subvolume ID. This makes it tricky to easily recover subvolumes using older snapshots because the kernel will still be looking for the subvolume ID of the original subvolume. Subvolid can still be used but requires additional steps to be taken during the snapshotting and recovery process that can be avoided by relying specificallly on the subvolume name.</p>

<p>Chroot into the install:</p>

<pre><code>arch-chroot /mnt /bin/bash
</code></pre>

<p>Edit the <code>/etc/mkinitcpio.conf</code> file to include the <code>encrypt</code> HOOK before the filesystems hook:</p>

<pre><code>HOOKS=&quot;... encrypt ... filesystems ...&quot;
</code></pre>

<p>Regenerate the initramfs image with the <code>encrypt</code> hook:</p>

<pre><code>mkinitcpio -p linux
</code></pre>

<p>Install the systemd-boot bootloader:</p>

<pre><code>bootctl install
</code></pre>

<p>This will by default install the bootloader in <code>/boot</code>.</p>

<p>Create a file in <code>/boot/loader/entires</code> called <code>arch.conf</code>. Determine the unique UUID of the encrypted partition (<code>/dev/sda3</code>) and of the btrfs LUKS container (<code>/dev/mapper/btrfsroot</code>)..</p>

<pre><code>title   Arch Linux
linux   /vmlinuz-linux
initrd  /initramfs-linux.img
options cryptdevice=UUID=&lt;/dev/sda3 UUID&gt;:btrfsroot root=UUID=&lt;/dev/mapper/btrfsroot UUID&gt; rootflags=subvol=__arch/root rw quiet
</code></pre>

<p>Do not include the chevrons (&lt;, &gt;) in the file. Configure the rest of the system and reboot. Enter the password on restart that was chosen when creating the encrypted LUKS container.</p>

<h2 id="snapshots">Snapshots</h2>

<p>Snapshots are very straightforward in Btrfs. They act as another subvolume linked to the original. They take up almost no space unless changes are made on the original subvolume in which case they retain the files and hierarchy that existed at the time of the creation of the snapshot.</p>

<p>To create a snapshot the subvolume must be mounted.</p>

<pre><code>btrfs subvolume snapshot /home /.snapshots/home-$(date &quot;+%F&quot;)
</code></pre>

<p>This will create a complete copy of the <code>__arch/home</code> subvolume in <code>__snapshots</code>.</p>

<p>Because snapshots act as subvolumes they can be viewed, deleted and mounted them the same way.</p>

<pre><code>btrfs subvolume list /
btrfs subvolume delete /.snapshots/home-2016-01-25
mount -o subvol=__snapshots/home-2016-01-25 /dev/mapper/btrfsroot /mnt/home-snapshots
</code></pre>

<p>Snapshots and Subvolumes behave in many ways similar to directories and so they can be renamed using the <code>mv</code> command.</p>

<pre><code>mv /.snapshots/home-2016-01-25 /.snapshots/home/2016-01-25
</code></pre>

<p>In order to rollback to a snapshot, first mount the toplevel Btrfs subvolume and simply replace the desired subvolume with the preferred snapshot.</p>

<pre><code>mkdir /mnt/btrfs-toplevel
mount /dev/mapper/btrfsroot /mnt/btrfs-toplevel
cd /mnt/btrfs-toplevel
mv __arch/home __arch/home-old
mv __snapshots/home-2016-01-25 __arch/home
</code></pre>

<p>Then reboot and the kernel will mount the new <code>__arch/home</code> subvolume rather than the <code>__arch/home-old</code> because fstab determines the appropriate subvolume by name not ID in which case it would attemp to mount <code>__arch/home-old</code> again.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://bassamsaeed.ca/post/starting-up/">
        Starting up with Jekyll and Github
      </a>
    </h1>

    <span class="post-date">Mon, Oct 26, 2015</span>

    

<p>I&rsquo;ve decided to actually create a website in order to document my learning as well as interesting information or methodology I stumble across. Essentially a way for me to keep track of certain details that I might need to refer back to. Maybe it&rsquo;ll be helpful for others too.</p>

<p>Up to this point I&rsquo;ve used a self-hosted wiki to manage this type of information (as well as cooking recipes). This blog is meant to be essentially an extension of that with more detail and my thought process and reasoning behind the decisions I make. Over time I&rsquo;ll probably transfer some information from the wiki over to here in a nicer format.</p>

<h2 id="journey-to-jekyll">Journey to Jekyll</h2>

<p>Static site generators had always interested me. I&rsquo;d had enough experience with overwrought dynamic CMSs to be a little tired of them. I really don&rsquo;t see the need for them for my small little website. I also generally like to be as close as possible to the actual code as I can. Abstractions on top of abstractions get a little tedious for me.</p>

<p>This isn&rsquo;t my first time experimenting with static site generators. I actually built one myself for a client&rsquo;s website a few years ago. It was more of a programming project than an attempt at a viable, commercial generator. I used Python for the actual generator while making use of the Jinja2 template engine. Honestly I was pretty proud of it. Especially for what amounted to a weekends worth of work.</p>

<p>A few days ago when I actually decided to set up this website I considered using my own generator for this site. But I quickly realized that it would need quite a bit of work to function as an actual blog generator. And among the publicly available generators, Jekyll was used automatically by Github Pages (which this site is hosted on). Hence my decision. It doesn&rsquo;t hurt that Jekyll is the most popular and so there&rsquo;s a lot of resources available for it. Finally, I have <em>zero</em> experience with Ruby so it might be a nice learning tool if I ever end up going into the nitty-gritty of Jekyll.</p>

<h2 id="setting-up-github-pages-and-initializing-jekyll">Setting up Github Pages and initializing Jekyll</h2>

<p>Creating a Github site for myself was fairly straightforward. A simple repository with a <em>CNAME Record</em> file that let&rsquo;s Github know my custom domain. And finally a few <em>A Records</em> with my domain pointed to Github. It&rsquo;s incredibly simple and straightforward.</p>

<p>Setting up Ruby on my computer was an interesting experience. I recently got a Macbook Pro which would be my first experience with OS X since a Grade 10 Communications course. So I figured I&rsquo;d set it up first on the Macbook rather than my Linux box. The first thing everyone seems to recommend is to install Homebrew, the presumably best package manager on OS X. From there it&rsquo;s on to setting up Ruby.</p>

<p>There&rsquo;s a lot of different ways of setting up Ruby installs it seems. My version of OS X came with Ruby 2.0.0 pre-installed but I wanted the latest stable which, at the time of writing, was 2.2.3. There&rsquo;s a multitude of ways to accomplish this but I settled on using ruby-install for the actual installation and chruby to manage the various Ruby installs.</p>

<p>The next step was configuring my Ruby environment. Bundler is helpful in this because it ensures all the Ruby gems match the correct version needed. All I had to do was create a simply <em>Gemfile</em> file with the names of all the gems I wanted (and their specific versions if needed). In my case the only gem I needed was Jekyll.</p>

<p>I forwent using the github-pages gem in favour of setting up my Jekyll system myself. After Bundler installed Jekyll, all I had to do was run <code>jekyll new .</code> in my repository. Jekyll then built the entire framework which I haven&rsquo;t touched at all so far. The only change will be this post.</p>

<h2 id="to-infinity">To Infinity</h2>

<p>Going forward I&rsquo;m going to keep this website incredibly simple. There&rsquo;s going to be a design change from this default Jekyll skin but I doubt I&rsquo;ll be doing anything truly fancy. I generally prefer a minimalistic style but we&rsquo;ll see if I&rsquo;ll build something a little more complex than Richard Stallman&rsquo;s website.</p>

<p>Hopefully this&rsquo;ll be fun.</p>

<p>Or at least interesting.</p>

  </div>
  
</div>
</div>

  </body>
</html>
